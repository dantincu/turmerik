{"mappings":"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","sources":["src/index.ts","src/core.ts","src/indexedDB/index.ts","src/indexedDB/core.ts"],"sourcesContent":["import * as core from \"./core\";\r\n\r\nimport * as idxedDB from \"./indexedDB\";\r\n\r\nexport const browser = {\r\n  ...core,\r\n  indexedDB: idxedDB.indexedDB,\r\n};\r\n\r\nexport type TrmrkIdxedDBType = idxedDB.TrmrkIdxedDBType;\r\nexport type TrmrkDBResp<T> = idxedDB.TrmrkDBRespType<T>;\r\nexport type IdxedDBInitOpts = idxedDB.IdxedDBInitOpts;\r\n","import { core as trmrk } from \"trmrk\";\r\n\r\nexport const absUriRegex =\r\n  /^[\\w\\-_]+\\:\\/\\/([\\w\\-_]+\\.?)+(\\:[0-9]+)?(\\/[\\w\\-\\?\\.\\+_&=#,]*)*$/g;\r\n\r\nexport const getNewUri = (\r\n  query?: URLSearchParams | null | undefined,\r\n  hash?: string | null | undefined,\r\n  path?: string | null | undefined,\r\n  host?: string | null | undefined,\r\n  preserveQueryDelim?: boolean | null | undefined\r\n) => {\r\n  const queryStr = query?.toString();\r\n\r\n  const partsArr = [host, path].filter((part) =>\r\n    trmrk.isNonEmptyStr(part, true)\r\n  );\r\n\r\n  let newUri = partsArr.join(\"/\");\r\n\r\n  if (preserveQueryDelim || trmrk.isNonEmptyStr(queryStr, true)) {\r\n    newUri = [newUri, queryStr].join(\"?\");\r\n  }\r\n\r\n  if (trmrk.isNonEmptyStr(hash)) {\r\n    newUri += hash;\r\n  }\r\n\r\n  return newUri;\r\n};\r\n\r\nexport const getRelUri = (\r\n  queryParams: URLSearchParams,\r\n  queryParamsTransformer: (query: URLSearchParams) => void,\r\n  hashTransformer?:\r\n    | ((hash?: string | null | undefined) => string | null | undefined)\r\n    | null\r\n    | undefined,\r\n  pathTransformer?:\r\n    | ((hash?: string | null | undefined) => string | null | undefined)\r\n    | null\r\n    | undefined,\r\n  preserveQueryDelim?: boolean | null | undefined\r\n) => {\r\n  queryParamsTransformer(queryParams);\r\n  hashTransformer ??= (hash) => hash;\r\n\r\n  pathTransformer ??= (path) => {\r\n    if (typeof path === \"string\") {\r\n      if (path.startsWith(\"/\")) {\r\n        path = path.substring(1);\r\n      }\r\n\r\n      if (path.endsWith(\"/\")) {\r\n        path = path.substring(0, path.length - 1);\r\n      }\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n  const hash = hashTransformer(location.hash);\r\n  const path = pathTransformer(location.pathname);\r\n\r\n  const newUri = getNewUri(queryParams, hash, path, null, preserveQueryDelim);\r\n  return newUri;\r\n};\r\n","import * as core from \"./core\";\r\n\r\nexport const indexedDB = {\r\n  ...core,\r\n};\r\nexport type TrmrkIdxedDBType = core.TrmrkIdxedDBType;\r\nexport type TrmrkDBRespType<T> = core.TrmrkDBRespType<T>;\r\nexport type IdxedDBInitOpts = core.IdxedDBInitOpts;\r\n","import { SyncLock } from \"trmrk/src/sync-lock\";\r\n\r\nexport interface TrmrkDBStoreObjIdxOpts {\r\n  name: string;\r\n  keyPath: string | string[];\r\n  unique?: boolean;\r\n  dbOpts?: IDBIndexParameters;\r\n}\r\n\r\nexport interface TrmrkDBStoreObjOpts {\r\n  idxesArr: TrmrkDBStoreObjIdxOpts[];\r\n}\r\n\r\nexport interface TrmrkDBResp<T> {\r\n  data: T;\r\n  cacheMatch: boolean;\r\n  cacheError: any;\r\n}\r\n\r\nexport interface IdxedDBInitOpts {\r\n  dbName: string;\r\n  dbVersion?: number;\r\n  onIdxedDBSuccess?: ((ev: Event, db: IDBDatabase) => any) | undefined;\r\n  onIdxedDBerror?: ((ev: Event) => any) | undefined;\r\n  onIdxedDBupgradeneeded?:\r\n    | ((ev: IDBVersionChangeEvent, db: IDBDatabase) => Promise<IDBDatabase>)\r\n    | undefined;\r\n  onIdxedDBblocked?: ((ev: IDBVersionChangeEvent) => any) | undefined;\r\n}\r\n\r\nexport class TrmrkIdxedDB {\r\n  private readonly syncLock: SyncLock;\r\n\r\n  private _db: IDBDatabase | null = null;\r\n\r\n  dbName!: string;\r\n  version?: number | undefined;\r\n  onerror?: ((ev: Event) => any) | undefined;\r\n  onupgradeneeded?:\r\n    | ((ev: IDBVersionChangeEvent, db: IDBDatabase) => Promise<IDBDatabase>)\r\n    | undefined;\r\n  onblocked?: ((ev: IDBVersionChangeEvent) => any) | undefined;\r\n  onsuccess?: ((ev: Event, db: IDBDatabase) => any) | undefined;\r\n\r\n  constructor(dfTimeout: number | null | undefined = undefined) {\r\n    this.syncLock = new SyncLock(dfTimeout);\r\n  }\r\n\r\n  init(opts: IdxedDBInitOpts) {\r\n    this.dbName = opts.dbName;\r\n    this.version = opts.dbVersion;\r\n    this.onerror = opts.onIdxedDBerror;\r\n    this.onupgradeneeded = opts.onIdxedDBupgradeneeded;\r\n    this.onblocked = opts.onIdxedDBblocked;\r\n    this.onsuccess = opts.onIdxedDBSuccess;\r\n  }\r\n\r\n  public getDb(dbVersion: number | null | undefined = null) {\r\n    return this.syncLock.get<IDBDatabase>(\r\n      () =>\r\n        new Promise((resolve, reject) => {\r\n          if (this._db) {\r\n            resolve(this._db);\r\n          } else {\r\n            dbVersion ??= this.version;\r\n\r\n            if (dbVersion === 0) {\r\n              dbVersion = undefined;\r\n            }\r\n\r\n            const dbReq = indexedDB.open(this.dbName, dbVersion);\r\n\r\n            this.reqOnSuccess(dbReq, resolve);\r\n            this.reqOnError(dbReq, reject);\r\n            this.reqOnBlocked(dbReq, reject);\r\n\r\n            dbReq.onupgradeneeded = (ev: IDBVersionChangeEvent) => {\r\n              if (this.onupgradeneeded) {\r\n                const innerDbReq = indexedDB.open(this.dbName);\r\n\r\n                this.reqOnSuccess(innerDbReq, resolve);\r\n                this.reqOnError(innerDbReq, reject);\r\n                this.reqOnBlocked(innerDbReq, reject);\r\n\r\n                innerDbReq.onupgradeneeded = (ev: IDBVersionChangeEvent) => {\r\n                  this.onblocked?.call(this, ev);\r\n                  reject(ev);\r\n                };\r\n              } else {\r\n                reject(ev);\r\n              }\r\n            };\r\n\r\n            dbReq.onerror = (ev: Event) => {\r\n              this.onerror?.call(this, ev);\r\n              reject(ev);\r\n            };\r\n\r\n            dbReq.onblocked = (ev: IDBVersionChangeEvent) => {\r\n              this.onblocked?.call(this, ev);\r\n              reject(ev);\r\n            };\r\n          }\r\n        })\r\n    );\r\n  }\r\n\r\n  public async withDb<T>(\r\n    action: (db: IDBDatabase) => TrmrkDBResp<T>,\r\n    dbVersion: number | null | undefined = null\r\n  ) {\r\n    let resp: TrmrkDBResp<T>;\r\n\r\n    try {\r\n      var db = await this.getDb(dbVersion);\r\n      resp = action(db);\r\n    } catch (err: any) {\r\n      resp = {\r\n        cacheError: err,\r\n      } as TrmrkDBResp<T>;\r\n    }\r\n\r\n    return resp;\r\n  }\r\n\r\n  private reqOnSuccess(\r\n    dbReq: IDBOpenDBRequest,\r\n    resolve: (db: IDBDatabase | PromiseLike<IDBDatabase>) => void\r\n  ) {\r\n    dbReq.onsuccess = (ev: Event) => {\r\n      this._db = (ev.target as any).result as IDBDatabase;\r\n      this.onsuccess?.call(this, ev, this._db);\r\n      resolve(this._db);\r\n    };\r\n  }\r\n\r\n  private reqOnError(dbReq: IDBOpenDBRequest, reject: (reason?: any) => void) {\r\n    dbReq.onerror = (ev: Event) => {\r\n      this.onerror?.call(this, ev);\r\n      reject(ev);\r\n    };\r\n  }\r\n\r\n  private reqOnBlocked(\r\n    dbReq: IDBOpenDBRequest,\r\n    reject: (reason?: any) => void\r\n  ) {\r\n    dbReq.onblocked = (ev: IDBVersionChangeEvent) => {\r\n      this.onblocked?.call(this, ev);\r\n      reject(ev);\r\n    };\r\n  }\r\n}\r\n\r\nexport type TrmrkIdxedDBType = TrmrkIdxedDB;\r\nexport type TrmrkDBRespType<T> = TrmrkDBResp<T>;\r\n\r\nexport const createDBStore = (\r\n  db: IDBDatabase,\r\n  objStName: string,\r\n  keyPath: string,\r\n  opts: TrmrkDBStoreObjOpts\r\n) => {\r\n  const objSt = db.createObjectStore(objStName, {\r\n    keyPath: keyPath,\r\n  });\r\n\r\n  for (let idx of opts.idxesArr) {\r\n    const paramOpts = idx.dbOpts ?? {};\r\n    paramOpts.unique ??= idx.unique ?? false;\r\n\r\n    objSt.createIndex(idx.name, idx.keyPath, paramOpts);\r\n  }\r\n\r\n  return objSt;\r\n};\r\n\r\nexport const getOrCreateDbStore = (\r\n  db: IDBDatabase,\r\n  objStNamesArr: DOMStringList,\r\n  objStName: string,\r\n  keyPath: string,\r\n  opts: TrmrkDBStoreObjOpts\r\n) => {\r\n  if (!(objStName in objStNamesArr)) {\r\n    createDBStore(db, objStName, keyPath, opts);\r\n  }\r\n};\r\n"],"names":[],"version":3,"file":"index.js.map"}