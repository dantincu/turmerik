{"mappings":";;;;;;;;;;;;ACEO,MAAM,4CACX;AAEK,MAAM,4CAAY,CACvB,OACA,MACA,MACA,MACA;IAEA,MAAM,WAAW,OAAO;IAExB,MAAM,WAAW;QAAC;QAAM;KAAK,CAAC,MAAM,CAAC,CAAC,OACpC,CAAA,GAAA,WAAI,EAAE,aAAa,CAAC,MAAM;IAG5B,IAAI,SAAS,SAAS,IAAI,CAAC;IAE3B,IAAI,sBAAsB,CAAA,GAAA,WAAI,EAAE,aAAa,CAAC,UAAU,OACtD,SAAS;QAAC;QAAQ;KAAS,CAAC,IAAI,CAAC;IAGnC,IAAI,CAAA,GAAA,WAAI,EAAE,aAAa,CAAC,OACtB,UAAU;IAGZ,OAAO;AACT;AAEO,MAAM,4CAAY,CACvB,aACA,wBACA,iBAIA,iBAIA;IAEA,uBAAuB;IACvB,oBAAoB,CAAC,OAAS;IAE9B,oBAAoB,CAAC;QACnB,IAAI,OAAO,SAAS,UAAU;YAC5B,IAAI,KAAK,UAAU,CAAC,MAClB,OAAO,KAAK,SAAS,CAAC;YAGxB,IAAI,KAAK,QAAQ,CAAC,MAChB,OAAO,KAAK,SAAS,CAAC,GAAG,KAAK,MAAM,GAAG;QAE3C;QAEA,OAAO;IACT;IAEA,MAAM,OAAO,gBAAgB,SAAS,IAAI;IAC1C,MAAM,OAAO,gBAAgB,SAAS,QAAQ;IAE9C,MAAM,SAAS,0CAAU,aAAa,MAAM,MAAM,MAAM;IACxD,OAAO;AACT;;;;;;AChEO,MAAM,4CAAY;IACvB,GAAG,yBAAI;AACT;;;AFAO,MAAM,4CAAU;IACrB,GAAG,yBAAI;IACP,WAAW;AACb","sources":["src/index.ts","src/core.ts","src/indexedDB/index.ts","src/indexedDB/core.ts"],"sourcesContent":["import * as core from \"./core\";\r\n\r\nimport * as idxedDB from \"./indexedDB\";\r\n\r\nexport const browser = {\r\n  ...core,\r\n  indexedDB: idxedDB.indexedDB,\r\n};\r\n\r\nexport type TrmrkDBResp<T> = idxedDB.TrmrkDBRespType<T>;\r\n","import { core as trmrk } from \"trmrk\";\r\n\r\nexport const absUriRegex =\r\n  /^[\\w\\-_]+\\:\\/\\/([\\w\\-_]+\\.?)+(\\:[0-9]+)?(\\/[\\w\\-\\?\\.\\+_&=#,]*)*$/g;\r\n\r\nexport const getNewUri = (\r\n  query?: URLSearchParams | null | undefined,\r\n  hash?: string | null | undefined,\r\n  path?: string | null | undefined,\r\n  host?: string | null | undefined,\r\n  preserveQueryDelim?: boolean | null | undefined\r\n) => {\r\n  const queryStr = query?.toString();\r\n\r\n  const partsArr = [host, path].filter((part) =>\r\n    trmrk.isNonEmptyStr(part, true)\r\n  );\r\n\r\n  let newUri = partsArr.join(\"/\");\r\n\r\n  if (preserveQueryDelim || trmrk.isNonEmptyStr(queryStr, true)) {\r\n    newUri = [newUri, queryStr].join(\"?\");\r\n  }\r\n\r\n  if (trmrk.isNonEmptyStr(hash)) {\r\n    newUri += hash;\r\n  }\r\n\r\n  return newUri;\r\n};\r\n\r\nexport const getRelUri = (\r\n  queryParams: URLSearchParams,\r\n  queryParamsTransformer: (query: URLSearchParams) => void,\r\n  hashTransformer?:\r\n    | ((hash?: string | null | undefined) => string | null | undefined)\r\n    | null\r\n    | undefined,\r\n  pathTransformer?:\r\n    | ((hash?: string | null | undefined) => string | null | undefined)\r\n    | null\r\n    | undefined,\r\n  preserveQueryDelim?: boolean | null | undefined\r\n) => {\r\n  queryParamsTransformer(queryParams);\r\n  hashTransformer ??= (hash) => hash;\r\n\r\n  pathTransformer ??= (path) => {\r\n    if (typeof path === \"string\") {\r\n      if (path.startsWith(\"/\")) {\r\n        path = path.substring(1);\r\n      }\r\n\r\n      if (path.endsWith(\"/\")) {\r\n        path = path.substring(0, path.length - 1);\r\n      }\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n  const hash = hashTransformer(location.hash);\r\n  const path = pathTransformer(location.pathname);\r\n\r\n  const newUri = getNewUri(queryParams, hash, path, null, preserveQueryDelim);\r\n  return newUri;\r\n};\r\n","import * as core from \"./core\";\r\n\r\nexport const indexedDB = {\r\n  ...core,\r\n};\r\n\r\nexport type TrmrkDBRespType<T> = core.TrmrkDBRespType<T>;\r\n","export interface TrmrkDBResp<T> {\r\n  data: T;\r\n  cacheMatch: boolean;\r\n  cacheError: any;\r\n}\r\n\r\nexport type TrmrkDBRespType<T> = TrmrkDBResp<T>;\r\n"],"names":[],"version":3,"file":"index.js.map"}