@if ((trmrkNode.html ?? null) === null) {
<div [ngClass]="cssClass" [trmrkDynamicAttributes]="nodeAttrs">
  @if (formNode!.category === enums.TrmrkFormNodeCategory.Text) { @for
  (childTextNode of formNode!.text ?? []; let idx = $index; track
  childTextNode.id) {
  <trmrk-form-text-node
    [trmrkNode]="childTextNode"
    [trmrkPath]="childPath(idx)"
    [trmrkTemplatesMap]="trmrkTemplatesMap"
  ></trmrk-form-text-node>
  } } @if (formNode!.category === enums.TrmrkFormNodeCategory.Heading) {
  <h3 [trmrkDynamicAttributes]="controlAttrs" [ngClass]="controlCssClass">
    {{ formNode!.label }}
  </h3>
  } @if (isInputControl) {
  <mat-form-field
    [appearance]="trmrkNode.appearance?.matFormFieldAppearance ?? 'outline'"
    >@if ((formNode!.labelHtml ?? null) !== null) { @if (hasLabelRawHtml) {
    <div [innerHtml]="labelSafeHtml"></div>
    } @if (hasLabelHtmlTemplate) {
    <ng-container
      *ngTemplateOutlet="trmrkTemplatesMap![labelHtmlTemplateName]; context: { path: trmrkPath, node: trmrkNode }"
    ></ng-container>
    } } @if ((formNode!.labelHtml ?? null) === null && (formNode!.label ?? null)
    !== null) {<mat-label
      >{{formNode!.label}} @if (formNode!.isRequired) {
      <sup class="trmrk-required-text">*</sup> }</mat-label
    >} @if (formNode!.category === enums.TrmrkFormNodeCategory.Input) { @if
    (isMultiple) {
    <textarea
      matInput
      [trmrkDynamicAttributes]="controlAttrs"
      [value]="formNode!.value ?? ''"
      [ngClass]="controlCssClass"
      [formControl]="formControl!"
      [errorStateMatcher]="formControlErrorMatcher!"
      (focus)="inputFocus($event)"
      (blur)="inputFocus($event)"
      (focusin)="inputFocusIn($event)"
      (focusout)="inputFocusOut($event)"
      (change)="inputChange($event)"
      (keyup)="inputKeyUp($event)"
    ></textarea>
    } @if (!isMultiple) {
    <input
      matInput
      [type]="formNode!.inputType ?? 'text'"
      [value]="formNode!.value ?? ''"
      [trmrkDynamicAttributes]="controlAttrs"
      [ngClass]="controlCssClass"
      [formControl]="formControl!"
      [errorStateMatcher]="formControlErrorMatcher!"
      (focus)="inputFocus($event)"
      (blur)="inputFocus($event)"
      (focusin)="inputFocusIn($event)"
      (focusout)="inputFocusOut($event)"
      (change)="inputChange($event)"
      (keyup)="inputKeyUp($event)"
    />
    } } @if (formNode!.category === enums.TrmrkFormNodeCategory.Combobox) { @if
    (trmrkNode.appearance?.useNativeControl) {
    <select
      matNativeControl
      [trmrkDynamicAttributes]="controlAttrs"
      [ngClass]="[controlCssClass, 'trmrk-select']"
      [formControl]="formControl!"
      [errorStateMatcher]="formControlErrorMatcher!"
      (change)="inputChange($event)"
      (focus)="inputFocus($event)"
      (blur)="inputFocus($event)"
      (focusin)="inputFocusIn($event)"
      (focusout)="inputFocusOut($event)"
    >
      @for (option of formNode!.items!.value ?? []; track option.key) {
      <option
        [value]="option.key ?? null"
        [selected]="option.isSelected"
        [ngClass]="((option.key) ?? null) === null ? 'trmrk-has-no-value' : ''"
      >
        {{option.text}}
      </option>
      }
    </select>
    } @if (!trmrkNode.appearance?.useNativeControl) { @if ((formNode!.text ??
    null) !== null) {
    <mat-chip-grid #chipList>
      @for (selectedOption of comboboxSelectedOptions ?? []; track
      selectedOption.key) {
      <mat-chip
        [removable]="isMultiple"
        (click)="comboboxRemoveOption(selectedOption)"
      >
        {{ selectedOption.text }} @if (isMultiple) {
        <mat-icon matChipRemove>cancel</mat-icon> }
      </mat-chip>
      }
      <input
        type="text"
        #autocompleteInput
        [formControl]="formControl!"
        [matAutocomplete]="autocomplete"
        [matChipInputFor]="chipList"
        [matChipInputSeparatorKeyCodes]="comboboxOptionsSeparatorKeysCodes"
        [matChipInputAddOnBlur]="true"
        matAutocompleteTrigger
        #autoTrigger="matAutocompleteTrigger"
        (focus)="inputFocus($event)"
        (blur)="inputFocus($event)"
        (focusin)="inputFocusIn($event)"
        (focusout)="inputFocusOut($event)"
        (change)="inputChange($event)"
        (keyup)="inputKeyUp($event)"
        (matChipInputTokenEnd)="comboboxAddOptionFromInput($event)"
      />
      <button
        mat-icon-button
        class="trmrk-icon-btn trmrk-is-last"
        (click)="comboboxSelectAutocompleteDoneClick()"
      >
        <mat-icon class="trmrk-icon">done_outline</mat-icon>
      </button>
      <mat-autocomplete
        [ngClass]="[`trmrk-autocomplete-${trmrkNode.id}`]"
        #autocomplete="matAutocomplete"
        [displayWith]="comboboxDisplayFn"
      >
        @for (option of formNode!.items!.value ?? []; track option.key) {
        <mat-option
          [ngClass]="[option.isSelected ? 'trmrk-is-selected' : '']"
          [value]="option"
          (onSelectionChange)="comboboxSelectOption($event, option)"
        >
          {{ option.text }}
        </mat-option>
        }
      </mat-autocomplete>
    </mat-chip-grid>
    } @if ((formNode!.text ?? null) === null) {
    <mat-select
      [value]="formNode!.value ?? null"
      [trmrkDynamicAttributes]="controlAttrs"
      [ngClass]="controlCssClass"
      [formControl]="formControl!"
      [errorStateMatcher]="formControlErrorMatcher!"
      (focus)="inputFocus($event)"
      (blur)="inputFocus($event)"
      (focusin)="inputFocusIn($event)"
      (focusout)="inputFocusOut($event)"
    >
      @for (option of formNode!.items!.value ?? []; track option.key) {
      <mat-option
        [value]="option.key ?? null"
        [ngClass]="((option.key) ?? null) === null ? 'trmrk-has-no-value' : ''"
        (onSelectionChange)="comboboxSelectOption($event, option)"
        >{{option.text}}</mat-option
      >
      } </mat-select
    >} } } @if (formNode!.category === enums.TrmrkFormNodeCategory.Checkbox) { }
    @if (formNode!.category === enums.TrmrkFormNodeCategory.DatePicker) { } @if
    (formNode!.category === enums.TrmrkFormNodeCategory.DateTimePicker) { } @if
    (formControl!.invalid && formControl!.touched) {
    <mat-error> {{trmrkNode.errorMsg}} </mat-error>
    }</mat-form-field
  >
  } @if (formNode!.category === enums.TrmrkFormNodeCategory.Radio) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.RadioGroup) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.Button) {
  <button
    [trmrkDynamicAttributes]="controlAttrs"
    [ngClass]="controlCssClass"
    (click)="click($event)"
  >
    {{formNode!.label ?? ""}} @for (childTextNode of formNode!.text ?? []; let
    idx = $index; track childTextNode.id) {
    <trmrk-form-text-node
      [trmrkNode]="childTextNode"
      [trmrkPath]="childPath(idx)"
      [trmrkTemplatesMap]="trmrkTemplatesMap"
    ></trmrk-form-text-node>
    }
  </button>
  } @if (formNode!.category === enums.TrmrkFormNodeCategory.IconButton) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.HorizStrip) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.ThinHorizStrip) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.Group) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.Loading) { } @if
  (formNode!.category === enums.TrmrkFormNodeCategory.HorizRule) { } @if
  (formNode!.hasClearAllBtn) {
  <button mat-icon-button class="trmrk-icon-btn" (click)="clearNode()">
    <mat-icon class="trmrk-icon">close</mat-icon>
  </button>
  } @if (formNode!.hasSpinner) {
  <trmrk-spinner></trmrk-spinner> }
</div>
} @if ((trmrkNode.html ?? null) !== null) { @if (hasRawHtml) {
<div
  [ngClass]="trmrkNode.cssClass ?? ''"
  [trmrkDynamicAttributes]="trmrkNode.attrs ?? {}"
  [innerHtml]="safeHtml"
></div>
} @if (hasHtmlTemplate) {
<ng-container
  *ngTemplateOutlet="trmrkTemplatesMap![htmlTemplateName]; context: { path: trmrkPath, node: trmrkNode }"
></ng-container>
} }
