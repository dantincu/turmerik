{"mappings":"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","sources":["src/index.ts","src/core.ts","src/drive-item.ts","src/notes-app-config.ts","src/notes-item.ts","src/notes-path.ts","src/url.ts","src/sync-lock.ts"],"sourcesContent":["import * as coreObj from \"./core\";\r\nimport * as driveItem from \"./drive-item\";\r\nimport * as notesAppConfig from \"./notes-app-config\";\r\nimport * as notesItem from \"./notes-item\";\r\nimport * as notesPath from \"./notes-path\";\r\nimport * as url from \"./url\";\r\nimport { SyncLock as SyncLockT } from \"./sync-lock\";\r\n\r\nexport const core = {\r\n  ...coreObj,\r\n  driveItem,\r\n  notesAppConfig,\r\n  notesItem,\r\n  notesPath,\r\n  url,\r\n};\r\n\r\nexport const SyncLock = SyncLockT;\r\n// export type SyncLock = SyncLockT;\r\n","export const allWsRegex = /^\\s+$/g;\r\n\r\nexport interface MtblRefValue<T> {\r\n  value: T;\r\n}\r\n\r\nexport interface Kvp<TKey, TValue> {\r\n  key: TKey;\r\n  value: TValue;\r\n}\r\n\r\nexport const isNonEmptyStr = (arg: string | any, allWsSameAsEmpty = false) => {\r\n  let retVal = \"string\" === typeof arg;\r\n  retVal = retVal && arg !== \"\";\r\n\r\n  if (retVal && allWsSameAsEmpty) {\r\n    retVal = !allWsRegex.test(arg);\r\n  }\r\n\r\n  return retVal;\r\n};\r\n\r\nexport const findKvp = <TValue>(\r\n  arr: TValue[] | readonly TValue[],\r\n  predicate: (\r\n    value: TValue,\r\n    idx: number,\r\n    array: TValue[] | readonly TValue[]\r\n  ) => boolean\r\n) => {\r\n  let retIdx = -1;\r\n  let retVal: TValue | null = null;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const val = arr[i];\r\n\r\n    if (predicate(val, i, arr)) {\r\n      retIdx = i;\r\n      retVal = val;\r\n      break;\r\n    }\r\n  }\r\n\r\n  const retKvp: Kvp<number, TValue | null> = {\r\n    key: retIdx,\r\n    value: retVal,\r\n  };\r\n\r\n  return retKvp;\r\n};\r\n\r\nexport const forEach = <T>(\r\n  arr: T[],\r\n  callback: (item: T, idx: number, arr: T[]) => boolean | void\r\n) => {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (callback(arr[i], i, arr) === false) {\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\nexport const contains = <T>(arr: T[], item: T) => arr.indexOf(item) >= 0;\r\n\r\nexport const any = <T>(\r\n  arr: T[],\r\n  predicate: (item: T, idx: number, array: T[]) => boolean\r\n) => arr.filter(predicate).length >= 0;\r\n\r\nexport const containsAnyOfArr = (\r\n  inStr: string,\r\n  strArr: string[] | readonly string[],\r\n  matching?:\r\n    | MtblRefValue<Kvp<number, string | null | undefined>>\r\n    | null\r\n    | undefined\r\n) => {\r\n  matching ??= {\r\n    value: {\r\n      key: -1,\r\n      value: null,\r\n    },\r\n  };\r\n\r\n  const kvp = findKvp(strArr, (chr) => inStr.indexOf(chr) >= 0);\r\n  const retVal = kvp.key >= 0;\r\n\r\n  if (retVal) {\r\n    matching.value = kvp;\r\n  }\r\n\r\n  return retVal;\r\n};\r\n\r\nexport const containsAnyOfMx = (\r\n  inStr: string,\r\n  strMx: (string[] | readonly string[])[],\r\n  matching?:\r\n    | MtblRefValue<Kvp<number, Kvp<number, string | null | undefined>>>\r\n    | null\r\n    | undefined\r\n) => {\r\n  matching ??= {\r\n    value: {\r\n      key: -1,\r\n      value: {\r\n        key: -1,\r\n        value: null,\r\n      },\r\n    },\r\n  };\r\n\r\n  const innerMatching = {} as MtblRefValue<\r\n    Kvp<number, string | null | undefined>\r\n  >;\r\n\r\n  const kvp = findKvp(strMx, (strArr) =>\r\n    containsAnyOfArr(inStr, strArr, innerMatching)\r\n  );\r\n\r\n  const retVal = kvp.key >= 0;\r\n\r\n  if (retVal) {\r\n    matching.value = {\r\n      key: kvp.key,\r\n      value: innerMatching.value,\r\n    };\r\n  }\r\n\r\n  return retVal;\r\n};\r\n","export enum FileType {\r\n  plainText = 1,\r\n  document,\r\n  image,\r\n  audio,\r\n  video,\r\n  code,\r\n  binary,\r\n  zippedFolder,\r\n}\r\n\r\nexport enum OfficeLikeFileType {\r\n  word = 1,\r\n  excel,\r\n  powerPoint,\r\n}\r\n\r\nexport interface DriveItem {\r\n  idnf: string | null | undefined;\r\n  name: string;\r\n  displayName: string | null | undefined;\r\n  isFolder?: boolean | null | undefined;\r\n  isRootFolder?: boolean | null | undefined;\r\n  prIdnf: string | null | undefined;\r\n  fileType?: FileType | null | undefined;\r\n  officeFileType?: OfficeLikeFileType | null | undefined;\r\n  isTextFile?: boolean | null | undefined;\r\n  isImageFile?: boolean | null | undefined;\r\n  isVideoFile?: boolean | null | undefined;\r\n  isAudioFile?: boolean | null | undefined;\r\n}\r\n","export enum CmdCommand {\r\n  Help = 1,\r\n  ListNotes,\r\n  CreateNoteBook,\r\n  CreateNoteBookInternal,\r\n  CreateNote,\r\n  CreateNoteInternal,\r\n  CopyNotes,\r\n  DeleteNotes,\r\n  MoveNotes,\r\n  RenameNote,\r\n  UpdateNote,\r\n  ReorderNotes,\r\n  NormalizeNote,\r\n  NormalizeNoteIdxes,\r\n  NormalizeNotesHcy,\r\n}\r\n\r\nexport interface ArgOptionT {\r\n  fullArg: string;\r\n  shortArg: string;\r\n  description?: string | null | undefined;\r\n}\r\n\r\nexport interface ArgOptionsAggT {\r\n  help: ArgOptionT;\r\n  listNotes: ArgOptionT;\r\n  createNoteBook: ArgOptionT;\r\n  createNoteBookInternal: ArgOptionT;\r\n  createNote: ArgOptionT;\r\n  createNoteInternal: ArgOptionT;\r\n  copyNotes: ArgOptionT;\r\n  deleteNotes: ArgOptionT;\r\n  moveNotes: ArgOptionT;\r\n  renameNote: ArgOptionT;\r\n  updateNote: ArgOptionT;\r\n  reorderNotes: ArgOptionT;\r\n  normalizeNote: ArgOptionT;\r\n  normalizeNoteIdxes: ArgOptionT;\r\n  normalizeNotesHcy: ArgOptionT;\r\n\r\n  commandsMap: { [key: string]: ArgOptionT };\r\n}\r\n\r\nexport interface DirNamePfxesT {\r\n  mainPfx: string;\r\n  altPfx: string;\r\n  joinStr: string;\r\n  useAltPfx?: boolean | null | undefined;\r\n}\r\n\r\nexport interface DirNamesT {\r\n  noteBook: string;\r\n  noteFiles: string;\r\n  noteInternals: string;\r\n\r\n  noteInternalsPfxes: DirNamePfxesT;\r\n  NoteItemsPfxes: DirNamePfxesT;\r\n}\r\n\r\nexport interface DirNameIdxesT {\r\n  minIdx: number;\r\n  maxIdx: number;\r\n  incIdx: boolean;\r\n  fillGapsByDefault: boolean;\r\n  idxFmt: string;\r\n}\r\n\r\nexport interface FileNamesT {\r\n  noteBookJsonFileName: string;\r\n  noteItemJsonFileName: string;\r\n  noteItemMdFileName: string;\r\n  prependTitleToNoteMdFileName: boolean;\r\n  keepFileName: string;\r\n}\r\n\r\nexport interface FileContentsT {}\r\n\r\nexport interface NoteDirPairsT {\r\n  fileNameMaxLength: number;\r\n  serializeToJson: boolean;\r\n  allowGetRequestsToPersistChanges: boolean;\r\n  trmrkGuidInputName?: string | null | undefined;\r\n  argOpts: ArgOptionsAggT;\r\n  dirNames: DirNamesT;\r\n  noteDirNameIdxes: DirNameIdxesT;\r\n  noteInternalDirNameIdxes: DirNameIdxesT;\r\n  fileNames: FileNamesT;\r\n  fileContents: FileContentsT;\r\n}\r\n\r\nexport interface AppConfigData {\r\n  trmrkPfx: string;\r\n  isDevEnv: string;\r\n  requiredClientVersion: string;\r\n  noteDirPairs: NoteDirPairsT;\r\n  invalidFileNameChars: string[];\r\n  pathSep: string;\r\n  altPathSep: string;\r\n  isWinOS: boolean;\r\n  isLocalFileNotesApp: boolean;\r\n  clientUserUuid: string;\r\n}\r\n\r\nexport const getCommand = (\r\n  commandsMap: { [key: string]: ArgOptionT },\r\n  cmd: CmdCommand\r\n) => {\r\n  const cmdName = CmdCommand[cmd];\r\n  const cmdVal = commandsMap[cmdName];\r\n  return cmdVal;\r\n};\r\n\r\nexport const getCmd = (noteDirPairs: NoteDirPairsT, cmd: CmdCommand) =>\r\n  getCommand(noteDirPairs.argOpts.commandsMap, cmd);\r\n","export enum DirType {\r\n  shortName,\r\n  fullName,\r\n}\r\n\r\nexport enum DirCategory {\r\n  item,\r\n  internals,\r\n}\r\n\r\nexport enum InternalDir {\r\n  root = 1,\r\n  internals,\r\n  files,\r\n}\r\n\r\nexport interface NoteItem {\r\n  title?: string | null | undefined;\r\n  itemIdx?: number | null | undefined;\r\n  mdFileName?: string | null | undefined;\r\n  internalDirs?: { [key: number | string]: number } | null | undefined;\r\n  childItems?: { [key: number]: string } | null | undefined;\r\n  pinnedChildItemsSortOrder?: number[] | null | undefined;\r\n  childItemsSortOrder?: number[] | null | undefined;\r\n\r\n  childNodes: { [itemIdx: number]: NoteItem };\r\n}\r\n","import {\r\n  isNonEmptyStr,\r\n  containsAnyOfMx,\r\n  containsAnyOfArr,\r\n  Kvp,\r\n  findKvp,\r\n  MtblRefValue,\r\n} from \"./core\";\r\n\r\nimport { AppConfigData } from \"./notes-app-config\";\r\n\r\nexport const trmrkPathSep = \"/\";\r\nexport const trmrkPathStartTkn = \"<\";\r\n\r\nexport const trmrkHomePathTkn = \"~\";\r\nexport const trmrkHomePathStr = [trmrkPathStartTkn, trmrkHomePathTkn].join(\"\");\r\nexport const trmrkHomePathStartStr = [trmrkHomePathStr, trmrkPathSep].join(\"\");\r\n\r\nexport const getPath = (\r\n  pathParts: string[] | readonly string[],\r\n  relToTrmrkHome: boolean | null | undefined = null\r\n) => {\r\n  const partsArr = [...pathParts];\r\n\r\n  if (typeof relToTrmrkHome === \"boolean\") {\r\n    if (isNonEmptyStr(partsArr[0])) {\r\n      partsArr.splice(0, 0, \"\");\r\n    }\r\n\r\n    if (relToTrmrkHome === true) {\r\n      partsArr[0] = trmrkHomePathStr;\r\n    }\r\n  }\r\n\r\n  const path = partsArr.join(trmrkPathSep);\r\n  return path;\r\n};\r\n\r\nexport enum PathValidationErrCode {\r\n  None = 0,\r\n  NullOrEmpty,\r\n  InvalidPathChars,\r\n  IsNotRooted,\r\n}\r\n\r\nexport interface PathValidationResult {\r\n  isValid: boolean;\r\n  errCode: PathValidationErrCode;\r\n  invalidChar: Kvp<number, string | null | undefined>;\r\n}\r\n\r\nexport const dfPathValidationResult = () =>\r\n  ({\r\n    isValid: false,\r\n    errCode: PathValidationErrCode.None,\r\n    invalidChar: {\r\n      key: -1,\r\n      value: null,\r\n    },\r\n  } as PathValidationResult);\r\n\r\nexport const createInvalidSeqncs = (sep: string, opSep: string) => [\r\n  opSep,\r\n  sep + sep,\r\n  sep + \" \",\r\n  \" \" + sep,\r\n  sep + \".\",\r\n  \".\" + sep,\r\n];\r\n\r\nexport const baseInvalidSeqncs = Object.freeze([\"  \", \" .\", \"..\", \". \"]);\r\nexport const winInvalidSeqncs = Object.freeze(createInvalidSeqncs(\"\\\\\", \"/\"));\r\nexport const unixInvalidSeqncs = Object.freeze(createInvalidSeqncs(\"/\", \"\\\\\"));\r\n\r\nexport const getInvalidSeqncs = (isWinOs: boolean) =>\r\n  isWinOs ? winInvalidSeqncs : unixInvalidSeqncs;\r\n\r\nexport const normalizeIfNetworkPath = (\r\n  path: string,\r\n  sep: string,\r\n  allowNetworkPath: boolean\r\n) => {\r\n  if (allowNetworkPath) {\r\n    const dblSep = sep + sep;\r\n\r\n    if (path.startsWith(dblSep)) {\r\n      path = path.substring(1);\r\n    }\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\nexport const normalizeIfRelPath = (path: string, sep: string) => {\r\n  if (path.startsWith(\"..\" + sep)) {\r\n    path = path.substring(2);\r\n  } else if (path.startsWith(\".\" + sep)) {\r\n    path = path.substring(1);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\nexport const checkPathNotContainsInvalidChars = (\r\n  path: string,\r\n  result: PathValidationResult,\r\n  invalidStrMx: (string[] | readonly string[])[]\r\n) => {\r\n  let matching = {} as MtblRefValue<\r\n    Kvp<number, Kvp<number, string | null | undefined>>\r\n  >;\r\n\r\n  if (!(result.isValid = !containsAnyOfMx(path, invalidStrMx, matching))) {\r\n    result.errCode = PathValidationErrCode.InvalidPathChars;\r\n    result.invalidChar = matching.value.value;\r\n  }\r\n\r\n  return result.isValid;\r\n};\r\n\r\nexport const isValidRootedPathCore = (\r\n  cfg: AppConfigData,\r\n  path: string,\r\n  result: PathValidationResult\r\n) => {\r\n  if (!(result.isValid = isNonEmptyStr(path, true))) {\r\n    result.errCode = PathValidationErrCode.NullOrEmpty;\r\n  } else {\r\n    checkPathNotContainsInvalidChars(path, result, [\r\n      cfg.invalidFileNameChars,\r\n      baseInvalidSeqncs,\r\n    ]);\r\n  }\r\n\r\n  return result.isValid;\r\n};\r\n\r\nexport const isValidRootedPath = (\r\n  cfg: AppConfigData,\r\n  path: string,\r\n  result: PathValidationResult | null | undefined = null,\r\n  allowNetworkPath: boolean = true\r\n) => {\r\n  result ??= dfPathValidationResult();\r\n  result.isValid = isValidRootedPathCore(cfg, path, result);\r\n\r\n  if (result.isValid) {\r\n    path = normalizeIfNetworkPath(path, cfg.pathSep, allowNetworkPath);\r\n\r\n    if (\r\n      !(result.isValid =\r\n        path.startsWith(\"/\") || path.startsWith(trmrkHomePathStartStr))\r\n    ) {\r\n      result.errCode = PathValidationErrCode.IsNotRooted;\r\n    }\r\n  }\r\n\r\n  if (result.isValid) {\r\n    checkPathNotContainsInvalidChars(path, result, [unixInvalidSeqncs]);\r\n  }\r\n\r\n  return result.isValid;\r\n};\r\n\r\nexport const isValidRootedFsPath = (\r\n  cfg: AppConfigData,\r\n  path: string,\r\n  result: PathValidationResult | null | undefined = null,\r\n  allowNetworkPath: boolean = true\r\n) => {\r\n  result ??= dfPathValidationResult();\r\n\r\n  if (cfg.isWinOS) {\r\n    if ((result.isValid = /^[a-zA-Z]\\:/.test(path))) {\r\n      path = path.substring(2);\r\n    } else {\r\n      result.isValid = path.startsWith(\"\\\\\");\r\n    }\r\n  } else {\r\n    result.isValid = path.startsWith(\"/\");\r\n  }\r\n\r\n  if (result.isValid) {\r\n    path = normalizeIfNetworkPath(path, cfg.pathSep, allowNetworkPath);\r\n\r\n    result.isValid = checkPathNotContainsInvalidChars(path, result, [\r\n      cfg.invalidFileNameChars,\r\n      baseInvalidSeqncs,\r\n    ]);\r\n  } else {\r\n    result.errCode = PathValidationErrCode.IsNotRooted;\r\n  }\r\n\r\n  result.isValid =\r\n    result.isValid &&\r\n    checkPathNotContainsInvalidChars(path, result, [\r\n      getInvalidSeqncs(cfg.isWinOS),\r\n    ]);\r\n\r\n  return result.isValid;\r\n};\r\n\r\nexport const isValidPath = (\r\n  cfg: AppConfigData,\r\n  path: string,\r\n  result: PathValidationResult | null | undefined = null,\r\n  allowNetworkPath: boolean = true\r\n) => {\r\n  result ??= dfPathValidationResult();\r\n  path = normalizeIfRelPath(path, cfg.pathSep);\r\n\r\n  result.isValid = isValidRootedPath(cfg, path, result, allowNetworkPath);\r\n  return result.isValid;\r\n};\r\n\r\nexport const isValidFsPath = (\r\n  cfg: AppConfigData,\r\n  path: string,\r\n  result: PathValidationResult | null | undefined = null,\r\n  allowNetworkPath: boolean = true\r\n) => {\r\n  result ??= dfPathValidationResult();\r\n  path = normalizeIfRelPath(path, cfg.pathSep);\r\n\r\n  result.isValid = isValidRootedFsPath(cfg, path, result, allowNetworkPath);\r\n  return result.isValid;\r\n};\r\n","export const getBaseLocation = () => {\r\n  let baseLocation = [window.location.protocol, window.location.host].join(\r\n    \"//\"\r\n  );\r\n\r\n  return baseLocation;\r\n};\r\n","export class SyncLock {\r\n  private static readonly dfVal = BigInt(0);\r\n  private static readonly incVal = BigInt(1);\r\n\r\n  private readonly dfTimeout: number | undefined;\r\n  private readonly syncRoot = new BigInt64Array(1);\r\n\r\n  constructor(dfTimeout: number | null | undefined = undefined) {\r\n    this.dfTimeout = dfTimeout ?? undefined;\r\n  }\r\n\r\n  public run(action: () => Promise<void>, timeout?: number): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      if (\r\n        Atomics.add(this.syncRoot, 0, SyncLock.incVal) === SyncLock.dfVal ||\r\n        Atomics.wait(\r\n          this.syncRoot,\r\n          0,\r\n          SyncLock.dfVal,\r\n          timeout ?? this.dfTimeout\r\n        ) !== \"timed-out\"\r\n      ) {\r\n        action().then(\r\n          () => {\r\n            Atomics.sub(this.syncRoot, 0, SyncLock.incVal);\r\n            resolve();\r\n          },\r\n          (reason) => {\r\n            Atomics.sub(this.syncRoot, 0, SyncLock.incVal);\r\n            reject(reason);\r\n          }\r\n        );\r\n      } else {\r\n        reject(\r\n          new Error(\r\n            \"While waiting for previously enqueued actions to finish their execution, more than the specified timeout has elapsed\"\r\n          )\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  public get<T>(action: () => Promise<T>) {\r\n    return new Promise<T>((resolve, reject) => {\r\n      let retVal: T | null = null;\r\n\r\n      this.run(\r\n        () =>\r\n          new Promise<void>((rslv, rjct) => {\r\n            action().then((value) => {\r\n              retVal = value;\r\n              rslv();\r\n            }, rjct);\r\n          })\r\n      ).then(() => {\r\n        resolve(retVal!);\r\n      }, reject);\r\n    });\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"index.js.map"}