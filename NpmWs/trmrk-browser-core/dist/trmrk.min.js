var trmrk;(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{browser:()=>f});var r={};e.r(r),e.d(r,{allWsRegex:()=>s,any:()=>a,contains:()=>l,forEach:()=>d,isNonEmptyStr:()=>i});var n={};e.r(n),e.d(n,{absUriRegex:()=>h,getNewUri:()=>b,getRelUri:()=>u});var o={};e.r(o),e.d(o,{TrmrkIdxedDB:()=>g,createDBStore:()=>p,getOrCreateDbStore:()=>y});const s=/^\s+$/g,i=(e,t=!1)=>{let r="string"==typeof e;return r=r&&""!==e,r&&t&&(r=!s.test(e)),r},d=(e,t)=>{for(let r=0;r<e.length&&!1!==t(e[r],r,e);r++);},l=(e,t)=>e.indexOf(t)>=0,a=(e,t)=>e.filter(t).length>=0,c={...r},h=/^[\w\-_]+\:\/\/([\w\-_]+\.?)+(\:[0-9]+)?(\/[\w\-\?\.\+_&=#,]*)*$/g,b=(e,t,r,n,o)=>{const s=e?.toString();let i=[n,r].filter((e=>c.isNonEmptyStr(e,!0))).join("/");return(o||c.isNonEmptyStr(s,!0))&&(i=[i,s].join("?")),c.isNonEmptyStr(t)&&(i+=t),i},u=(e,t,r,n,o)=>{t(e),r??=e=>e,n??=e=>("string"==typeof e&&(e.startsWith("/")&&(e=e.substring(1)),e.endsWith("/")&&(e=e.substring(0,e.length-1))),e);const s=r(location.hash),i=n(location.pathname);return b(e,s,i,null,o)};class g{_dbReq=null;_db=null;dbName;version;onerror;onupgradeneeded;onblocked;onsuccess;init(e){this.dbName=e.dbName,this.version=e.dbVersion,this.onerror=e.onIdxedDBerror,this.onupgradeneeded=e.onIdxedDBupgradeneeded,this.onblocked=e.onIdxedDBblocked,this.onsuccess=e.onIdxedDBSuccess}getDb(){return new Promise(((e,t)=>{const r=this._db;if(r)e(r);else{let r=this._dbReq;r&&(r=indexedDB.open(this.dbName,this.version),this._dbReq=r,r.onsuccess=t=>{const r=t.target.result;this._db=r,this._dbReq=null,this.onsuccess?.call(this,t,r),e(r)},r.onerror=e=>{this._dbReq=null,this.onerror?.call(this,e),t(e)},r.onupgradeneeded=e=>{this._dbReq=null,this.onupgradeneeded?.call(this,e),t(e)},r.onblocked=e=>{this._dbReq=null,this.onblocked?.call(this,e),t(e)})}}))}async withDb(e){let t;try{t=e(await this.getDb())}catch(e){t={cacheError:e}}return t}}const p=(e,t,r,n)=>{const o=e.createObjectStore(t,{keyPath:r});for(let e of n.idxesArr){const t=e.dbOpts??{};t.unique??=e.unique??!1,o.createIndex(e.name,e.keyPath,t)}return o},y=(e,t,r,n,o)=>{r in t||p(e,r,n,o)},m={...o},f={...n,indexedDB:m};trmrk=t})();