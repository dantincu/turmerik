var trmrk;(()=>{"use strict";var e={d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{FsBackupsManager:()=>a,FsEntriesRetriever:()=>d,FsEntry:()=>l,allWsRegex:()=>r,any:()=>n,contains:()=>o,forEach:()=>s,fsBackupsManager:()=>c,isNonEmptyStr:()=>i,retrieveFsEntries:()=>h});const r=/^\s+$/g,i=(e,t=!1)=>{let i="string"==typeof e;return i=i&&""!==e,i&&t&&(i=r.test(e)),i},s=(e,t)=>{for(let r=0;r<e.length&&!1!==t(e[r],r,e);r++);},o=(e,t)=>e.indexOf(t)>=0,n=(e,t)=>e.filter(t).length>=0,h=async(e,t,r,i)=>(await i(t,r)).map((s=>new l(e,t,s.name,r,s.isFolder?i:null)));class l{parent;parentDirPath;name;dirSepStr;isFolder;childNodes;isIncluded=!1;isExcluded=!1;isResolved=!1;resolved=[];fsPath;folderFsEntriesRetriever;childrenCount=-1;resolvedChildrenCount=-1;constructor(e,t,r,i="/",s){this.parent=e,this.parentDirPath=t,this.name=r,this.dirSepStr=i,this.isFolder=!!s,this.childNodes=null,this.folderFsEntriesRetriever=s??(async()=>{throw new Error("Calling this method on a file entry is not allowed")})}isRootFolder(){return!this.parent}isRootLevel(){return this.parent.isRootFolder}async forEachChild(e){await this.assureChildrenRetrieved();for(let t=0;t<this.childNodes.length;t++)await e(this.childNodes[t],t,this.childNodes)}async include(e=0){this.isIncluded=!0,this.isExcluded=!1;let t=!this.isFolder;if(!t){if(e>0){const t=e-1;await this.forEachChild((async e=>{await e.include(t)}))}else await this.assureChildrenRetrieved();t=e>=0&&0===this.childrenCount}this.parent&&!this.parent.isIncluded&&this.parent.include(e),t&&this.resolveIfReq()}exclude(){this.isExcluded=!0,this.isIncluded=!1,this.resolveIfReq()}excludeUnresolved(){this.isResolved||(this.isFolder?this.resolvedChildrenCount>0?s(this.childNodes,(e=>{e.isResolved||e.exclude()})):this.isIncluded?this.resolveIfReq():this.exclude():this.exclude())}async retrieveChildren(){this.fsPath??=[this.parentDirPath,this.name].join(this.dirSepStr);const e=await h(this,this.fsPath,this.dirSepStr,this.folderFsEntriesRetriever);return s(e,(e=>{e.resolved.push((()=>{this.resolvedChildrenCount++,this.resolvedChildrenCount>=this.childrenCount&&this.resolveIfReq()}))})),[e,e.length]}async assureChildrenRetrieved(){if(!this.childNodes){const[e,t]=await this.retrieveChildren();this.childNodes=e,this.childrenCount=t,this.resolvedChildrenCount=0}}resolveIfReq(){const e=!this.isResolved;return e&&this.resolve(),e}resolve(){this.isResolved=!0,this.onResolved()}onResolved(){for(let e of this.resolved)e(this)}}class d{rootParentPath;rootDirName;dirSepStr;folderFsEntriesRetriever;forEachChildCallback;rootPath;constructor(e,t,r="/",i,s){this.rootParentPath=e,this.rootDirName=t,this.dirSepStr=r,this.folderFsEntriesRetriever=i,this.forEachChildCallback=s,this.rootPath=[e,t].join(r)}async run(){return new Promise(((e,t)=>{const r=new l(null,this.rootParentPath,this.rootDirName,this.dirSepStr,this.folderFsEntriesRetriever);let i=!1;r.resolved.push((t=>{i||(i=!0,e(t))})),r.forEachChild(this.forEachChildCallback).then((()=>{i||(i=!0,e(r))}),(e=>t(e)))}))}}class a{runtimeData;constructor(){}getFsEntriesRetriever(e,t){return this.throwIfPropsNotInitialized(),new d(e,"",this.runtimeData.dirSepStr,this.runtimeData.folderFsEntriesRetriever,t)}throwIfPropsNotInitialized(){if(!this.runtimeData)throw new Error("The runtimeData must be set");if(!this.runtimeData.folderFsEntriesRetriever)throw new Error("The runtimeData.folderFsEntriesRetriever must be set");if(!this.runtimeData.dirSepStr)throw new Error("The runtimeData.dirSepStr must be set")}}const c=new a;trmrk=t})();