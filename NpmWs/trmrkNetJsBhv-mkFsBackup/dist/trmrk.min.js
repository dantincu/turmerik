var trmrk;(()=>{"use strict";var e={d:(t,i)=>{for(var s in i)e.o(i,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:i[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{FsEntriesRetriever:()=>d,FsEntry:()=>n,allWsRegex:()=>i,any:()=>h,contains:()=>o,forEach:()=>r,isNonEmptyStr:()=>s,retrieveFsEntries:()=>l});const i=/^\s+$/g,s=(e,t=!1)=>{let s="string"==typeof e;s=s&&""!==e,s&&t&&(s=i.test(e))},r=(e,t)=>{for(let i=0;i<e.length&&!1!==t(e[i],i,e);i++);},o=(e,t)=>e.indexOf(t)>=0,h=(e,t)=>e.filter(t).length>=0,l=async(e,t,i,s)=>(await s(t,i)).map((r=>new n(e,t,r.name,i,r.isFolder?s:null)));class n{parent;parentDirPath;name;dirSepStr;isFolder;childNodes;isIncluded=!1;isExcluded=!1;isResolved=!1;resolved=[];fsPath;folderFsEntriesRetriever;childrenCount=-1;resolvedChildrenCount=-1;constructor(e,t,i,s="/",r){this.parent=e,this.parentDirPath=t,this.name=i,this.dirSepStr=s,this.isFolder=!!r,this.childNodes=null,this.folderFsEntriesRetriever=r??(async()=>{throw new Error("Calling this method on a file entry is not allowed")})}isRootFolder(){return!this.parent}isRootLevel(){return this.parent.isRootFolder}async forEachChild(e){await this.assureChildrenRetrieved();for(let t=0;t<this.childNodes.length;t++)await e(this.childNodes[t],t,this.childNodes)}async include(e=0){this.isIncluded=!0,this.isExcluded=!1;let t=!this.isFolder;if(!t){if(e>0){const t=e-1;await this.forEachChild((async e=>{await e.include(t)}))}else await this.assureChildrenRetrieved();t=e>=0&&0===this.childrenCount}this.parent&&!this.parent.isIncluded&&this.parent.include(e),t&&this.resolveIfReq()}exclude(){this.isExcluded=!0,this.isIncluded=!1,this.resolveIfReq()}excludeUnresolved(){this.isResolved||(this.isFolder?this.resolvedChildrenCount>0?r(this.childNodes,(e=>{e.isResolved||e.exclude()})):this.isIncluded?this.resolveIfReq():this.exclude():this.exclude())}async retrieveChildren(){this.fsPath??=[this.parentDirPath,this.name].join(this.dirSepStr);const e=await l(this,this.fsPath,this.dirSepStr,this.folderFsEntriesRetriever);return r(e,(e=>{e.resolved.push((()=>{this.resolvedChildrenCount++,this.resolvedChildrenCount>=this.childrenCount&&this.resolveIfReq()}))})),[e,e.length]}async assureChildrenRetrieved(){if(!this.childNodes){const[e,t]=await this.retrieveChildren();this.childNodes=e,this.childrenCount=t,this.resolvedChildrenCount=0}}resolveIfReq(){const e=!this.isResolved;return e&&this.resolve(),e}resolve(){this.isResolved=!0,this.onResolved()}onResolved(){for(let e of this.resolved)e(this)}}class d{rootParentPath;rootDirName;dirSepStr;folderFsEntriesRetriever;forEachChildCallback;rootPath;constructor(e,t,i="/",s,r){this.rootParentPath=e,this.rootDirName=t,this.dirSepStr=i,this.folderFsEntriesRetriever=s,this.forEachChildCallback=r,this.rootPath=[e,t].join(i)}async run(){return new Promise(((e,t)=>{const i=new n(null,this.rootParentPath,this.rootDirName,this.dirSepStr,this.folderFsEntriesRetriever);let s=!1;i.resolved.push((t=>{s||(s=!0,e(t))})),i.forEachChild(this.forEachChildCallback).then((()=>{s||(s=!0,e(i))}),(e=>t(e)))}))}}trmrk=t})();